# Spotify Recommendation

## Running the Program
When running main.py you will see the main program window. This window will include an Entry box, where input can be typed, a listbox where the recommendations will be displayed (will be blank when the program is first launched), a button which can be pressed to submit the typed song, and 4 check buttons. To interact with the program you can write a song into the Entry box. The song you enter must match a song in the playlist\_data.txt dataset exactly in order to be counted as valid input. Next, you can select any combination of the check buttons on the left side of the screen. Whichever buttons are checked will result in their corresponding property being used in the recommendation computations. Then, you can press the button that says 'Get Recommendation' in order to generate recommendations from that song. Once this button is pressed, if the input is valid and there are recommendations available, up to 5 recommendation will be displayed in the listbox. 

## Topic Overview
The creation and distribution of music has been a fundamental aspect of our society for an incredibly long time. Whether it is utilized for pain and anxiety management, improving one's mood, or in a social setting, music has truly made its way into the lives of the general population (NorthShore, 2021). Though society’s love for music has been unchanging, the ways in which it consumes it is constantly evolving. Presently, online streaming services are dominating the music distribution industry, with Spotify becoming a giant in the music streaming space. With a constantly expanding user base of over 100 million users as of 2018, Spotify was able to grow as a platform through the development of a user oriented and personalized listening experience (Bibbiani, 2019). Spotify utilizes its expansive collection of user, artist, and music data in order to generate personalized playlists such as Discover Weekly, Release Radar and Daily Mix. Each of these playlists provide a user with a collection of songs based on their preferred artists and music genre which is extrapolated from their listening activity (Bibbiani, 2019). Personally, music has played and continues to play a large role in my life making this project topic especially important, interesting and applicable to me. I always try to expand upon my music taste, looking for new songs and artists which may interest me. As an avid user of Spotify, their algorithm which works to personalize one’s experience on the platform has been incredibly useful for me, constantly providing me with an array of new music that fit my music taste. In addition to generally improving my music listening experience this algorithm has also peaked my interest. It made me wonder, **how can I use a Spotify user’s listening preferences, the data of other user’s with similar interests, and the functionalities of graphs to provide listening recommendations?**

## Technical Overview
Foremost, a major component of my program's computation was the creating of Graph and \_Vertex datatypes from my chosen datasets. This computation primarily occurs in the main.py module and more specifically the generate\_graph function. The function's primarily transforms a dataset of users and playlists they have created, which are taken from the playlist\_data.txt, into a graph where there are two types of vertices, a user and a song, and the edges represent a user adding a song to one of their playlists. A song vertex holds additional information about the songs as its properties, which is taken from the song\_data.txt dataset, such as the energy, liveness, loudness, and tempo of the song, as well as the song name is the item value of each song vertex. Thus, this function utilizes the playlist data and cross references it with more specific song data in order to generate a graph with weighted edges (the amount of times a song is added by a single user, or the likeablility) and two vertex types. 

The recommendation algorithm is made up of the adjacency_similarity\_score and the property\_similarity methods in the graph module, as well as the get\_recommendation and \_max\_similarity methods in the recommendation module. For the adjacency\_similarity\_score method I take advantage of the adjacency property of the Graph datatype. Given two vertices, I compute both the amount of vertices from the graph that are adjacent to both given vertices and the amount of vertices that are adjacent to either of the given vertices. My taking advantage of this property I am able to get an effective similarity score that portrays how similar the neighbours of each vertex are. Furthermore, for the property\_similarity method I utilized the properties component of a given \_Vertex in order to analyze how similar each vertex's song properties are. Based on this I generated an average variation score, which was then added to the score generated in the previous method to make a total similarity score that I can then work with. Moreover, the \_max\_similarity method, which when given a song goes through all the vertices of a given graph and computes the similarity score of each one. It then works to determine the vertex with the largest similarity score (that has not been a previous largest score), which is then returned by the function. The get\_recommendation method then utilizes the \_max\_similarity method as a helper method, adding the song with the top similarity score to a list of recommendations which it then returns
